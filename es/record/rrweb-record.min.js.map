{"version":3,"file":"rrweb-record.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js","../../src/utils.ts","../../src/types.ts","../../src/record/collection.ts","../../src/record/observer.ts","../../src/record/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nvar _id = 1;\nfunction genId() {\n    return _id++;\n}\nfunction resetId() {\n    _id = 1;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules\n            ? Array.from(rules).reduce(function (prev, cur) { return (prev += cur.cssText); }, '')\n            : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction extractOrigin(url) {\n    var origin;\n    if (url.indexOf('//') > -1) {\n        origin = url\n            .split('/')\n            .slice(0, 3)\n            .join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nvar DATA_URI = /^(data:)([\\w\\/\\+]+);(charset=[\\w-]+|base64).*,(.*)/gi;\nfunction absoluteToStylesheet(cssText, href) {\n    return cssText.replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url('\" + filePath + \"')\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + filePath + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url('\" + (extractOrigin(href) + filePath) + \"')\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url('\" + stack.join('/') + \"')\";\n    });\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction serializeNode(n, doc, blockClass) {\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            return {\n                type: NodeType.Document,\n                childNodes: []\n            };\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId\n            };\n        case n.ELEMENT_NODE:\n            var needBlock = n.classList.contains(blockClass);\n            var tagName = n.tagName.toLowerCase();\n            var attributes_1 = {};\n            for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {\n                var _b = _a[_i], name = _b.name, value = _b.value;\n                if (name === 'src' || name === 'href') {\n                    attributes_1[name] = absoluteToDoc(doc, value);\n                }\n                else if (name === 'style') {\n                    attributes_1[name] = absoluteToStylesheet(value, location.href);\n                }\n                else {\n                    attributes_1[name] = value;\n                }\n            }\n            if (tagName === 'link') {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = getCssRulesString(stylesheet);\n                if (cssText) {\n                    delete attributes_1.rel;\n                    delete attributes_1.href;\n                    attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n                }\n            }\n            if (tagName === 'style' &&\n                n.sheet &&\n                !n.innerText.trim().length) {\n                var cssText = getCssRulesString(n\n                    .sheet);\n                if (cssText) {\n                    attributes_1._cssText = absoluteToStylesheet(cssText, location.href);\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    value) {\n                    attributes_1.value = value;\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                var selectValue = n.parentElement;\n                if (attributes_1.value === selectValue.value) {\n                    attributes_1.selected = n.selected;\n                }\n            }\n            if (needBlock) {\n                var _c = n.getBoundingClientRect(), width = _c.width, height = _c.height;\n                attributes_1.rr_width = width + \"px\";\n                attributes_1.rr_height = height + \"px\";\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            if (isStyle && textContent) {\n                textContent = absoluteToStylesheet(textContent, location.href);\n            }\n            if (parentTagName === 'SCRIPT') {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: ''\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || ''\n            };\n        default:\n            return false;\n    }\n}\nfunction serializeNodeWithId(n, doc, map, blockClass, skipChild) {\n    if (skipChild === void 0) { skipChild = false; }\n    var _serializedNode = serializeNode(n, doc, blockClass);\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: genId()\n    });\n    n.__sn = serializedNode;\n    map[serializedNode.id] = n;\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var serializedChildNode = serializeNodeWithId(childN, doc, map, blockClass);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n    }\n    return serializedNode;\n}\nfunction snapshot(n, blockClass) {\n    if (blockClass === void 0) { blockClass = 'rr-block'; }\n    resetId();\n    var idNodeMap = {};\n    return [serializeNodeWithId(n, n, idNodeMap, blockClass), idNodeMap];\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient'\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nvar CSS_SELECTOR = /([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)/g;\nvar HOVER_SELECTOR = /([^\\\\]):hover/g;\nfunction addHoverClass(cssText) {\n    return cssText.replace(CSS_SELECTOR, function (match, p1, p2) {\n        if (HOVER_SELECTOR.test(p1)) {\n            var newSelector = p1.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n            return p1.replace(/\\s*$/, '') + \", \" + newSelector.replace(/^\\s*/, '') + p2;\n        }\n        else {\n            return match;\n        }\n    });\n}\nfunction buildNode(n, doc) {\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name, n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node = void 0;\n            if (n.isSVG) {\n                node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node = doc.createElement(tagName);\n            }\n            for (var name in n.attributes) {\n                if (n.attributes.hasOwnProperty(name) && !name.startsWith('rr_')) {\n                    var value = n.attributes[name];\n                    value = typeof value === 'boolean' ? '' : value;\n                    var isTextarea = tagName === 'textarea' && name === 'value';\n                    var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n                    if (isRemoteOrDynamicCss) {\n                        value = addHoverClass(value);\n                    }\n                    if (isTextarea || isRemoteOrDynamicCss) {\n                        var child = doc.createTextNode(value);\n                        node.appendChild(child);\n                        continue;\n                    }\n                    if (tagName === 'iframe' && name === 'src') {\n                        continue;\n                    }\n                    try {\n                        node.setAttribute(name, value);\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (n.attributes.rr_width) {\n                        node.style.width = n.attributes.rr_width;\n                    }\n                    if (n.attributes.rr_height) {\n                        node.style.height = n.attributes\n                            .rr_height;\n                    }\n                }\n            }\n            return node;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle ? addHoverClass(n.textContent) : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, doc, map, skipChild) {\n    if (skipChild === void 0) { skipChild = false; }\n    var node = buildNode(n, doc);\n    if (!node) {\n        return null;\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var childNode = buildNodeWithSN(childN, doc, map);\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction rebuild(n, doc) {\n    var idNodeMap = {};\n    return [buildNodeWithSN(n, doc, idNodeMap), idNodeMap];\n}\n\nexport { snapshot, serializeNodeWithId, resetId, rebuild, buildNodeWithSN, NodeType };\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n} from './types';\nimport { INode } from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport const mirror: Mirror = {\n  map: {},\n  getId(n) {\n    // if n is not a serialized INode, use -1 as its id.\n    if (!n.__sn) {\n      return -1;\n    }\n    return n.__sn.id;\n  },\n  getNode(id) {\n    return mirror.map[id] || null;\n  },\n  // TODO: use a weakmap to get rid of manually memory management\n  removeNodeFromMap(n) {\n    const id = n.__sn && n.__sn.id;\n    delete mirror.map[id];\n    if (n.childNodes) {\n      n.childNodes.forEach(child =>\n        mirror.removeNodeFromMap((child as Node) as INode),\n      );\n    }\n  },\n  has(id) {\n    return mirror.map.hasOwnProperty(id);\n  },\n};\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n): hookResetter {\n  const original = Object.getOwnPropertyDescriptor(target, key);\n  Object.defineProperty(target, key, {\n    set(value) {\n      // put hooked setter into event loop to avoid of set latency\n      setTimeout(() => {\n        d.set!.call(this, value);\n      }, 0);\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    },\n  });\n  return () => hookSetter(target, key, original || {});\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: string): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    return (\n      (node as HTMLElement).classList.contains(blockClass) ||\n      isBlocked(node.parentNode, blockClass)\n    );\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isAncestorRemoved(target: INode): boolean {\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode);\n}\n","import { serializedNodeWithId, idNodeMap, INode } from 'rrweb-snapshot';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source: IncrementalSource.MouseMove;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimention;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type recordOptions = {\n  emit?: (e: eventWithTime, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: string;\n  ignoreClass?: string;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  blockClass: string;\n  ignoreClass: string;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  previousId: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\ntype mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (p: mousePosition[]) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove,\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type viewportResizeDimention = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimention) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n};\n\nexport type playerMetaData = {\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n}\n","/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\n\nimport { INode } from 'rrweb-snapshot';\nimport { removedNodeMutation } from '../types';\nimport { mirror } from '../utils';\n\nexport function deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach(childN => deepDelete(addsSet, childN));\n}\n\nexport function isParentRemoved(\n  removes: removedNodeMutation[],\n  n: Node,\n): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some(r => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode);\n}\n\nexport function isParentDropped(droppedSet: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (droppedSet.has(parentNode)) {\n    return true;\n  }\n  return isParentDropped(droppedSet, parentNode);\n}\n","import { INode, serializeNodeWithId } from 'rrweb-snapshot';\nimport {\n  mirror,\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isAncestorRemoved,\n} from '../utils';\nimport {\n  mutationCallBack,\n  removedNodeMutation,\n  addedNodeMutation,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  textCursor,\n  attributeCursor,\n} from '../types';\nimport { deepDelete, isParentRemoved, isParentDropped } from './collection';\n\n/**\n * Mutation observer will merge several mutations into an array and pass\n * it to the callback function, this may make tracing added nodes hard.\n * For example, if we append an element el_1 into body, and then append\n * another element el_2 into el_1, these two mutations may be passed to the\n * callback function together when the two operations were done.\n * Generally we need trace child nodes of newly added node, but in this\n * case if we count el_2 as el_1's child node in the first mutation record,\n * then we will count el_2 again in the secoond mutation record which was\n * duplicated.\n * To avoid of duplicate counting added nodes, we will use a Set to store\n * added nodes and its child nodes during iterate mutation records. Then\n * collect added nodes from the Set which will has no duplicate copy. But\n * this also cause newly added node will not be serialized with id ASAP,\n * which means all the id related calculation should be lazy too.\n * @param cb mutationCallBack\n */\nfunction initMutationObserver(\n  cb: mutationCallBack,\n  blockClass: string,\n): MutationObserver {\n  const observer = new MutationObserver(mutations => {\n    const texts: textCursor[] = [];\n    const attributes: attributeCursor[] = [];\n    const removes: removedNodeMutation[] = [];\n    const adds: addedNodeMutation[] = [];\n\n    const addsSet = new Set<Node>();\n    const droppedSet = new Set<Node>();\n\n    const genAdds = (n: Node) => {\n      if (isBlocked(n, blockClass)) {\n        return;\n      }\n      addsSet.add(n);\n      droppedSet.delete(n);\n      n.childNodes.forEach(childN => genAdds(childN));\n    };\n    mutations.forEach(mutation => {\n      const {\n        type,\n        target,\n        oldValue,\n        addedNodes,\n        removedNodes,\n        attributeName,\n      } = mutation;\n      switch (type) {\n        case 'characterData': {\n          const value = target.textContent;\n          if (!isBlocked(target, blockClass) && value !== oldValue) {\n            texts.push({\n              value,\n              node: target,\n            });\n          }\n          break;\n        }\n        case 'attributes': {\n          const value = (target as HTMLElement).getAttribute(attributeName!);\n          if (isBlocked(target, blockClass) || value === oldValue) {\n            return;\n          }\n          let item: attributeCursor | undefined = attributes.find(\n            a => a.node === target,\n          );\n          if (!item) {\n            item = {\n              node: target,\n              attributes: {},\n            };\n            attributes.push(item);\n          }\n          // overwrite attribute if the mutations was triggered in same time\n          item.attributes[attributeName!] = value;\n          break;\n        }\n        case 'childList': {\n          addedNodes.forEach(n => genAdds(n));\n          removedNodes.forEach(n => {\n            const nodeId = mirror.getId(n as INode);\n            const parentId = mirror.getId(target as INode);\n            if (isBlocked(n, blockClass)) {\n              return;\n            }\n            // removed node has not been serialized yet, just remove it from the Set\n            if (addsSet.has(n)) {\n              deepDelete(addsSet, n);\n              droppedSet.add(n);\n            } else if (addsSet.has(target) && nodeId === -1) {\n              /**\n               * If target was newly added and removed child node was\n               * not serialized, it means the child node has been removed\n               * before callback fired, so we can ignore it.\n               * TODO: verify this\n               */\n            } else if (isAncestorRemoved(target as INode)) {\n              /**\n               * If parent id was not in the mirror map any more, it\n               * means the parent node has already been removed. So\n               * the node is also removed which we do not need to track\n               * and replay.\n               */\n            } else {\n              removes.push({\n                parentId,\n                id: nodeId,\n              });\n            }\n            mirror.removeNodeFromMap(n as INode);\n          });\n          break;\n        }\n        default:\n          break;\n      }\n    });\n\n    Array.from(addsSet).forEach(n => {\n      if (!isParentDropped(droppedSet, n) && !isParentRemoved(removes, n)) {\n        adds.push({\n          parentId: mirror.getId((n.parentNode as Node) as INode),\n          previousId: !n.previousSibling\n            ? n.previousSibling\n            : mirror.getId(n.previousSibling as INode),\n          nextId: !n.nextSibling\n            ? n.nextSibling\n            : mirror.getId((n.nextSibling as unknown) as INode),\n          node: serializeNodeWithId(n, document, mirror.map, blockClass, true)!,\n        });\n      } else {\n        droppedSet.add(n);\n      }\n    });\n\n    const payload = {\n      texts: texts\n        .map(text => ({\n          id: mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter(text => mirror.has(text.id)),\n      attributes: attributes\n        .map(attribute => ({\n          id: mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter(attribute => mirror.has(attribute.id)),\n      removes,\n      adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n    cb(payload);\n  });\n  observer.observe(document, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMousemoveObserver(cb: mousemoveCallBack): listenerHandler {\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle(() => {\n    const totalOffset = Date.now() - timeBaseline!;\n    cb(\n      positions.map(p => {\n        p.timeOffset -= totalOffset;\n        return p;\n      }),\n    );\n    positions = [];\n    timeBaseline = null;\n  }, 500);\n  const updatePosition = throttle<MouseEvent>(\n    evt => {\n      const { clientX, clientY, target } = evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb();\n    },\n    50,\n    {\n      trailing: false,\n    },\n  );\n  return on('mousemove', updatePosition);\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  blockClass: string,\n): listenerHandler {\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = event;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(key => Number.isNaN(Number(key)))\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler));\n    });\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  blockClass: string,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>(evt => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === document) {\n      const scrollEl = (document.scrollingElement || document.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    cb({\n      width: Number(width),\n      height: Number(height),\n    });\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  blockClass: string,\n  ignoreClass: string,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    const text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      document\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach(el => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const handlers: Array<listenerHandler | hookResetter> = [\n    'input',\n    'change',\n  ].map(eventName => on(eventName, eventHandler));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(p =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\n\nexport default function initObservers(o: observerParam): listenerHandler {\n  const mutationObserver = initMutationObserver(o.mutationCb, o.blockClass);\n  const mousemoveHandler = initMousemoveObserver(o.mousemoveCb);\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.blockClass,\n  );\n  const scrollHandler = initScrollObserver(o.scrollCb, o.blockClass);\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.blockClass,\n    o.ignoreClass,\n  );\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n  };\n}\n","import { snapshot } from 'rrweb-snapshot';\nimport initObservers from './observer';\nimport { mirror, on, getWindowWidth, getWindowHeight } from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n} from '../types';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nfunction record(options: recordOptions = {}): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    ignoreClass = 'rr-ignore',\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  const wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    emit(e, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  function takeFullSnapshot(isCheckout = false) {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n    const [node, idNodeMap] = snapshot(document, blockClass);\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left: document.documentElement!.scrollLeft,\n            top: document.documentElement!.scrollTop,\n          },\n        },\n      }),\n    );\n  }\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n    const init = () => {\n      takeFullSnapshot();\n\n      handlers.push(\n        initObservers({\n          mutationCb: m =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Mutation,\n                  ...m,\n                },\n              }),\n            ),\n          mousemoveCb: positions =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseMove,\n                  positions,\n                },\n              }),\n            ),\n          mouseInteractionCb: d =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.MouseInteraction,\n                  ...d,\n                },\n              }),\n            ),\n          scrollCb: p =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Scroll,\n                  ...p,\n                },\n              }),\n            ),\n          viewportResizeCb: d =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.ViewportResize,\n                  ...d,\n                },\n              }),\n            ),\n          inputCb: v =>\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.IncrementalSnapshot,\n                data: {\n                  source: IncrementalSource.Input,\n                  ...v,\n                },\n              }),\n            ),\n          blockClass,\n          ignoreClass,\n        }),\n      );\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach(h => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nexport default record;\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","_id","genId","resetId","getCssRulesString","rules","cssRules","Array","from","reduce","prev","cur","cssText","error","extractOrigin","url","indexOf","split","slice","join","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","path1","path2","path3","filePath","test","stack","parts","pop","_i","parts_1","part","push","absoluteToDoc","doc","attributeValue","a","createElement","isSVGElement","el","tagName","SVGElement","serializeNode","blockClass","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","name","publicId","systemId","ELEMENT_NODE","needBlock","classList","contains","toLowerCase","attributes_1","_a","attributes","_b","value","location","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","trim","checked","selectValue","parentElement","selected","_c","getBoundingClientRect","width","height","rr_width","rr_height","Element","isSVG","undefined","TEXT_NODE","parentTagName","parentNode","textContent","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","map","skipChild","_serializedNode","console","warn","serializedNode","id","__sn","recordChild","serializedChildNode","snapshot","idNodeMap","on","fn","target","options","capture","passive","addEventListener","removeEventListener","EventType","IncrementalSource","MouseInteractions","ReplayerEvents","mirror","getId","getNode","removeNodeFromMap","forEach","child","has","throttle","func","wait","timeout","previous","now","Date","leading","remaining","context","args","window","clearTimeout","trailing","setTimeout","hookSetter","key","d","original","getOwnPropertyDescriptor","defineProperty","set","_this","getWindowHeight","innerHeight","document","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","node","isAncestorRemoved","deepDelete","addsSet","childN","isParentRemoved","removes","parentId","some","r","isParentDropped","droppedSet","initMutationObserver","cb","observer","MutationObserver","mutations","texts","adds","Set","genAdds","add","mutation","oldValue","addedNodes","removedNodes","attributeName","getAttribute","item","nodeId","previousId","previousSibling","nextId","nextSibling","payload","text","filter","attribute","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","initMousemoveObserver","timeBaseline","positions","wrappedCb","totalOffset","timeOffset","evt","clientX","clientY","x","y","initMouseInteractionObserver","handlers","keys","Number","isNaN","eventKey","eventName","handler","event","getHandler","h","initScrollObserver","scrollEl","scrollingElement","scrollLeft","scrollTop","initViewportResizeObserver","INPUT_TAGS","lastInputValueMap","WeakMap","initInputObserver","ignoreClass","eventHandler","isChecked","cbWithDedup","querySelectorAll","v","lastInputValue","get","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initObservers","o","mutationObserver","mutationCb","mousemoveHandler","mousemoveCb","mouseInteractionHandler","mouseInteractionCb","scrollHandler","scrollCb","viewportResizeHandler","viewportResizeCb","inputHandler","inputCb","disconnect","wrapEvent","e","timestamp","record","lastFullSnapshotEvent","emit","checkoutEveryNms","checkoutEveryNth","Error","incrementalSnapshotCount","wrappedEmit","isCheckout","FullSnapshot","IncrementalSnapshot","exceedCount","exceedTime","takeFullSnapshot","Meta","data","initialOffset","left","top","handlers_1","DomContentLoaded","init_1","m","source","Mutation","MouseMove","MouseInteraction","Scroll","ViewportResize","Input","readyState","Load"],"mappings":"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"}